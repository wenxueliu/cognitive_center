---
title: Claude Code 完整功能使用指南
type: note
permalink: output/zettelkasten/claude-code-完整功能使用指南
tags:
- Claude Code, AI编程, 最佳实践, 企业应用]}
---

# Claude Code 完整功能使用指南

## 概述

这是一篇关于 Claude Code 全功能使用的综合性指南，作者 Shrivu Shankar 从业余爱好者和企业使用者的双重角度，详细分享了他使用 Claude Code 每个功能的经验和最佳实践。

## 核心内容

### 1. CLAUDE.md 项目配置文件

CLAUDE.md 是使用 Claude Code 最重要的文件，它是代理的"宪法"，是了解特定代码库工作方式的主要真实来源。

#### 最佳实践原则
- **从护栏开始，而非手册**：根据 Claude 出错的地方来记录文档
- **不要 @-引用文档**：避免在 CLAUDE.md 中嵌入整个文件，会膨胀上下文窗口
- **避免只说"绝不"**：总是提供替代方案，如"不要使用 X，优先使用 Y"
- **作为强制函数使用**：保持 CLAUDE.md 尽可能简洁，是简化代码库和内部工具的绝佳强制函数

#### 企业级管理
- 作者团队的 monorepo CLAUDE.md 严格维护，当前大小为 13KB
- 只记录 30% 或更多工程师使用的工具和 API
- 为每个内部工具分配最大令牌计数，就像出售"广告位"给团队
- 与 AGENTS.md 文件同步，保持与其他 AI IDE 的兼容性

### 2. 上下文管理策略

#### 上下文窗口使用
- 建议在编码会话中至少运行一次 `/context` 来了解如何使用 200k 令牌上下文窗口
- 作者的 monorepo 新会话基线成本约 20k 令牌（10%），剩余 180k 用于变更

#### 三种主要工作流程
1. **`/compact`（避免使用）**：自动压缩不透明且容易出错
2. **`/clear` + `/catchup`（简单重启）**：默认重启方式，清除状态后让 Claude 读取 git 分支中所有更改的文件
3. **"文档并清除"（复杂重启）**：大型任务时让 Claude 将计划和进度转储到 .md 文件，清除状态后开始新会话

### 3. 自定义斜杠命令

作者采用极简设置：
- **`/catchup`**：提示 Claude 读取当前 git 分支中所有更改的文件
- **`/pr`**：清理代码、暂存并准备拉取请求的简单助手

#### 设计理念
- 如果有复杂的自定义斜杠命令列表，就创建了反模式
- 目标是让工程师几乎可以输入任何内容并获得有用的、可合并的结果
- 不应强迫工程师学习新的、记录在某处的魔法命令列表才能完成工作

### 4. 子代理策略

#### 理论与实践的差距
理论上，自定义子代理是上下文管理最强大的功能：
- 复杂任务需要 X 令牌输入上下文
- 累积 Y 令牌工作上下文
- 产生 Z 令牌答案
- N 个任务意味着 (X + Y + Z) * N 令牌

#### 实践中的问题
1. **它们把守上下文**：隐藏了所有测试上下文，主代理不再能整体推理变更
2. **它们强制人工工作流程**：强制 Claude 进入僵化的人工定义工作流程

#### 更好的替代方案
- 使用 Claude 内置的 Task(...) 功能来生成通用代理的克隆
- 将所有关键上下文放在 CLAUDE.md 中
- 让主代理决定何时以及如何将工作委托给自己的副本
- 代理动态管理自己的编排

作者称之为"主-克隆"架构，强烈偏好于此而非自定义子代理鼓励的"领导-专家"模型。

### 5. 会话恢复和历史分析

#### 基础使用
- 经常使用 `claude --resume` 和 `claude --continue`
- 重启错误的终端或快速重启旧会话
- 恢复几天前的会话，询问代理如何克服特定错误，然后用于改进 CLAUDE.md

#### 高级分析
- Claude Code 将所有会话历史存储在 `~/.claude/projects/`
- 作者有脚本对这些日志进行元分析，寻找常见异常、权限请求和错误模式
- 帮助改进面向代理的上下文

### 6. 钩子系统

钩子对复杂企业仓库至关重要，是确定性的"必须做"规则，补充 CLAUDE.md 中的"应该做"建议。

#### 两种主要类型
1. **提交时阻止钩子**：主要策略
   - 包装任何 `Bash(git commit)` 命令的 PreToolUse 钩子
   - 检查 `/tmp/agent-pre-commit-pass` 文件
   - 测试脚本只在所有测试通过时创建该文件
   - 如果文件缺失，钩子阻止提交，强制 Claude 进入"测试修复"循环

2. **提示钩子**：简单、非阻塞钩子
   - 在代理做次优操作时提供"即发即忘"反馈

#### 最佳实践
- 故意不使用"写入时阻止"钩子（如 Edit 或 Write）
- 中间计划阻止会混淆甚至"挫败"代理
- 更有效的方法是让它完成工作，然后在提交阶段检查最终完成的结果

### 7. 规划模式

规划对于任何使用 AI IDE 的"大型"功能变更都至关重要。

#### 个人项目
- 专门使用内置规划模式
- 在 Claude 开始之前对齐的方式
- 定义如何构建某物以及需要停止并向其展示工作的"检查点"
- 定期使用可以建立强烈的直觉，了解获得良好计划而不让 Claude 搞砸实施所需的最少上下文

#### 企业级规划工具
- 基于 Claude Code SDK 构建的自定义规划工具
- 与原生规划模式类似，但大量提示以与现有技术设计格式对齐输出
- 开箱即用地强制执行内部最佳实践——从代码结构到数据隐私和安全
- 让工程师像高级架构师一样"氛围规划"新功能

### 8. 技能 vs MCP 的演进

#### 代理自主性的三个阶段
1. **单一提示**：在一个巨大提示中给代理所有上下文（脆弱，不可扩展）
2. **工具调用**："经典"代理模型，手工制作工具并为代理抽象现实（更好，但创建新抽象和上下文瓶颈）
3. **脚本编写**：给代理访问原始环境——二进制文件、脚本和文档——它动态编写代码与它们交互

#### 技能的优势
- 技能是"脚本编写"层代理模型的正式产品化
- SKILL.md 文件是更有组织、可共享和可发现的方式来记录这些 CLI 和脚本
- 它们将代理形式化，比 MCP 代表的僵化、类似 API 模型更强大灵活

#### MCP 的新角色
MCP 仍然有价值，但角色发生变化：
- 不应是臃肿的 API
- 应该是简单的、安全网关，提供少数强大的高级工具
- 职责是管理认证、网络和安全边界，然后为代理提供入口点
- 作者只将 MCP 用于 Playwright（复杂、有状态的环境），所有无状态工具已迁移到简单 CLI

### 9. Claude Code SDK 的高级应用

Claude Code 不仅仅是交互式 CLI，还是构建全新代理的强大 SDK。

#### 三种主要用途
1. **大规模并行脚本编写**：
   - 大型重构、错误修复或迁移不使用交互式聊天
   - 编写简单的 bash 脚本并行调用 `claude -p "in /pathA change all refs from foo to bar"`
   - 比让主代理管理数十个子代理任务更具可扩展性和可控性

2. **构建内部聊天工具**：
   - SDK 非常适合将复杂过程包装在非技术用户的简单聊天界面中
   - 出错时回退到 Claude Code SDK 为用户直接修复问题
   - 构建"v0-at-home"工具，让设计团队在公司 UI 框架中氛围编码模拟前端

3. **快速代理原型制作**：
   - 最常见的用途，不仅用于编码
   - 任何代理任务的想法都使用 Claude Code SDK 快速构建和测试原型
   - 在承诺完整、部署的脚手架之前

### 10. GitHub Actions 集成

Claude Code GitHub Action 是作者最喜欢且最被忽视的功能之一。

#### 核心价值
- 简单概念：在 GHA 中运行 Claude Code
- 可完全自定义容器和环境
- 比任何其他产品提供更多数据访问和更强的沙盒和审计控制
- 支持所有高级功能，如钩子和 MCP

#### 应用场景
- 构建"来自任何地方的 PR"工具
- 用户可以从 Slack、Jira 甚至 CloudWatch 警报触发 PR
- GHA 将修复错误或添加功能并返回完全测试的 PR
- 定期检查日志以发现常见错误、bash 错误或未对齐的工程实践

#### 数据驱动飞轮
```
错误 → 改进的 CLAUDE.md / CLI → 更好的代理
```

### 11. 高级设置配置

#### 关键配置项
- **HTTPS_PROXY/HTTP_PROXY**：调试时检查 Claude 发送的原始提示
- **MCP_TOOL_TIMEOUT/BASH_MAX_TIMEOUT_MS**：增加超时时间以运行复杂命令
- **ANTHROPIC_API_KEY**：企业 API 密钥，从"每人席"许可证转向"基于使用"定价
- **"permissions"**：偶尔自审计已允许 Claude 自动运行的命令列表

#### 企业级优势
- 解决工程师使用的巨大差异（观察到 1:100 倍差异）
- 让工程师尝试非 Claude Code LLM 脚本，全部在企业单一账户下

## 核心洞察

### 设计哲学
1. **简单优于复杂**：避免过度工程化和不必要的抽象
2. **上下文优先**：给予代理充分上下文而非僵化工作流程
3. **脚本化胜过 API 化**：让代理编写代码与工具交互而非预定义 API 调用
4. **数据驱动改进**：通过分析日志和错误模式持续改进

### 实施建议
1. **从小开始**：CLAUDE.md 应从小的护栏文档开始，逐步完善
2. **关注工具使用**：记录 Claude 实际出错的地方，而非所有可能性
3. **避免文档爆炸**：保持简洁，作为简化工具开发的强制函数
4. **拥抱脚本编写**：优先使用简单 CLI 而非复杂的 MCP 集成

### 组织转型
- 从"人类制造供人类审查"到"AI 发起供人类审查"的范式转变
- 建立新的审查流程（如 AI 发起的 PR 需要 2 个人工批准）
- 将 Claude Code 从个人工具转变为工程系统的核心、可审计、自我改进的部分

## 结论

这篇指南展示了 Claude Code 的全部功能生态系统，从基础配置文件到高级 SDK 应用。作者强调，CLI 代理空间正在变得拥挤，真正的比赛在 Anthropic 和 OpenAI 之间展开，但工具选择往往归结为功能实现的"幸运"或系统提示的"感觉"。

通过遵循这些最佳实践，团队可以将 Claude Code 从简单的编程助手转变为工程系统的核心组成部分，实现真正的 AI 辅助软件开发革命。